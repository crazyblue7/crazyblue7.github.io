<html>
    <head>
        <link rel="icon" href="sadguy.png" type="image/x-icon">
        <title>some situation, drawing app too</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div class="drawing-container">
            <canvas id="drawingCanvas" width="500" height="500"></canvas>
            <div class="controls">
                <label for="brushSizeSlider">Brush Size: </label>
                <input type="range" id="brushSizeSlider" min="1" max="50" value="5">
                <label for="colorPicker">Pick a color:</label>
                <input type="color" id="colorPicker" class="color-picker" value="#000000">
                <button id="clearCanvasButton" class="clear-button">Clear Canvas</button>
                <button id="brushButton" class="mode-button">Brush Mode</button>
                <button id="eraserButton" class="mode-button">Eraser Mode</button>
            </div>
        </div>

        <script>
            const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');

// Off-screen canvas for persistent drawing
const offscreenCanvas = document.createElement('canvas');
offscreenCanvas.width = canvas.width;
offscreenCanvas.height = canvas.height;
const offscreenCtx = offscreenCanvas.getContext('2d');

let isDrawing = false;
let isErasing = false;
let lastX = 0;
let lastY = 0;
let brushRadius = 5; // Size of the brush and eraser preview
let currentColor = 'black'; // Default color

// Prevent the default scrolling behavior on mobile
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    lastX = touch.clientX - canvas.offsetLeft;
    lastY = touch.clientY - canvas.offsetTop;
    isDrawing = true;
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const currentX = touch.clientX - canvas.offsetLeft;
    const currentY = touch.clientY - canvas.offsetTop;

    if (isDrawing) {
        const dx = currentX - lastX;
        const dy = currentY - lastY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, distance / 2);

        for (let i = 0; i < steps; i++) {
            const x = lastX + (dx / steps) * i;
            const y = lastY + (dy / steps) * i;
            draw(x, y);
        }
    } else if (isErasing) {
        erase(currentX, currentY);
    }

    lastX = currentX;
    lastY = currentY;

    // Redraw the preview
    redrawCanvasWithPreview(currentX, currentY);
});

canvas.addEventListener('touchend', () => {
    isDrawing = false;
    isErasing = false;
});

canvas.addEventListener('touchcancel', () => {
    isDrawing = false;
    isErasing = false;
});

// Event listeners for mouse actions (same as before)
canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) { // Left click for drawing
        isDrawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
    } else if (e.button === 2) { // Right click for erasing
        isErasing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (!isDrawing && !isErasing) return;
    const currentX = e.offsetX;
    const currentY = e.offsetY;

    if (isDrawing) {
        const dx = currentX - lastX;
        const dy = currentY - lastY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, distance / 2);

        for (let i = 0; i < steps; i++) {
            const x = lastX + (dx / steps) * i;
            const y = lastY + (dy / steps) * i;
            draw(x, y);
        }
    } else if (isErasing) {
        erase(currentX, currentY);
    }

    lastX = currentX;
    lastY = currentY;

    // Redraw the preview
    redrawCanvasWithPreview(currentX, currentY);
});

canvas.addEventListener('mouseup', () => {
    isDrawing = false;
    isErasing = false;
});

canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault(); // Prevent right-click context menu
});

function draw(x, y) {
    offscreenCtx.beginPath();
    offscreenCtx.arc(x, y, brushRadius, 0, Math.PI * 2); // Small circle for each point
    offscreenCtx.fillStyle = currentColor;
    offscreenCtx.fill();
}

function erase(x, y) {
    offscreenCtx.clearRect(x - brushRadius, y - brushRadius, brushRadius * 2, brushRadius * 2);
}

function redrawCanvasWithPreview(cursorX, cursorY) {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the main canvas
    ctx.drawImage(offscreenCanvas, 0, 0); // Draw the offscreen canvas onto the main canvas
    drawCursorPreview(cursorX, cursorY); // Draw the preview
}

function drawCursorPreview(x, y) {
    ctx.beginPath();
    ctx.arc(x, y, brushRadius, 0, Math.PI * 2);
    ctx.strokeStyle = isErasing ? 'red' : currentColor; // Red for eraser, color for brush
    ctx.lineWidth = 1;
    ctx.stroke();
}

// Event listener to change brush size
document.getElementById('brushSizeSlider').addEventListener('input', (e) => {
    brushRadius = parseInt(e.target.value, 10);
});

// Event listener to change color
document.getElementById('colorPicker').addEventListener('input', (e) => {
    currentColor = e.target.value;
});

// Function to clear both canvases
document.getElementById('clearCanvasButton').addEventListener('click', () => {
    offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    redrawCanvasWithPreview(-100, -100); // Move preview off-screen
});

// Event listeners for the buttons to toggle between Brush and Eraser modes
document.getElementById('brushButton').addEventListener('click', () => {
    isErasing = false;
    isDrawing = true;
});

document.getElementById('eraserButton').addEventListener('click', () => {
    isDrawing = false;
    isErasing = true;
});

        </script>
        <iframe width="720" height="405" src="https://www.youtube.com/embed/7aj_GwEEbnI?si=Kqbq6h4jrn-GXteF" title="uhh some situation" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </body>
</html>
